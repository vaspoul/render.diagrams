<html>
<head>

	<script type="text/javascript" src="../lib/maths.js"></script>
	<script type="text/javascript" src="../lib/graphics.js"></script>
	<script type="text/javascript" src="../lib/camera.js"></script>
	<script type="text/javascript" src="../lib/ui.js"></script>
	<script type="text/javascript" src="../lib/scene.js"></script>
	<script type="text/javascript" src="../lib/sceneObject_arcWall.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_axis.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_barChart.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_bouncingBall.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_brdfHemisphere.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_brdfRay.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_camera.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_dimension.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_editorInternals.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_functionGraph.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_line.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_ngon.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_pageOutline.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_parallelLight.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_pointLight.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_rectangle.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_spotLight.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_text.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/sceneObject_wall.js?v=1.0"></script>
	<script type="text/javascript" src="../lib/brdf.js"></script>
	<script type="text/javascript" src="../lib/embeddedDrawing.js"></script>

	<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css" />
	<link rel="stylesheet" href="http://renderdiagrams.org/wp-content/themes/structural/style.css" />
	<link rel="stylesheet" href="../styles.css" />
</head>


<body style="width:750px; margin:0 auto">

	<pre style="display:none;"><script>

			function ShowFilterFunctions(divName, controlsDivName, showBox, showTent, showGaussian)
			{
				var embeddedObj=new EmbeddedDrawing(divName);
				var scene=embeddedObj.getScene();
				var camera=embeddedObj.camera;

				var showBox = showBox;
				var showTent = showTent;
				var showGaussian = showGaussian;

				function addControls()
				{
					if (controlsDivName == undefined)
						return;

					var showBoxControl = new TickBox(showBox, function (value)
					{
						showBox = value;
						makeScene();
					});

					var showTentControl = new TickBox(showTent, function (value)
					{
						showTent = value;
						makeScene();
					});

					var showGaussianControl = new TickBox(showGaussian, function (value)
					{
						showGaussian = value;
						makeScene();
					});

					var controls = new PropertyGrid(document.getElementById(controlsDivName));

					controls.addProperty("Show Box Filter", showBoxControl);
					controls.addProperty("Show Tent Filter", showTentControl);
					controls.addProperty("Show Gaussian Filter", showGaussianControl);
				}

				function makeScene()
				{
					scene.deleteAllObjects();

					if (showBox)
					{
						var functionGraph = new FunctionGraph(new Vector(0, 0));
						functionGraph.appearance.lineWidth = 2;
						functionGraph.appearance.lineRGB[0] = 66;
						functionGraph.appearance.lineRGB[1] = 134;
						functionGraph.appearance.lineRGB[2] = 244;
						functionGraph.appearance.lineAlpha = 1;
						functionGraph.appearance.lineDashIndex = 0;
						functionGraph.appearance.fillRGB[0] = 255;
						functionGraph.appearance.fillRGB[1] = 127;
						functionGraph.appearance.fillRGB[2] = 0;
						functionGraph.appearance.fillAlpha = 0.5;
						functionGraph.functionStr = unescape("//%20Type%20your%20function%20here%2C%20using%20valid%20JavaScript.%0A//%0A//%20Parameters%3A%0A//%20%09x%3A%20%5BCartesian%5D%20The%20value%20on%20the%20X%20axis%20on%20which%20the%20function%20needs%20to%20be%20evaluated%20at.%0A//%20%09x%3A%20%5BPolar%5D%20The%20angle%2C%20in%20radians%2C%20which%20the%20function%20needs%20to%20be%20evaluated%20at.%0A//%0A//%20%09hitDistance%3A%20%5BCartesian%5D%20A%20ray%20is%20shot%20along%20the%20Y%20axis%2C%20starting%20at%20each%20evaluation%20position.%0A//%20%09hitDistance%3A%20%5BPolar%5D%20A%20ray%20is%20shot%20for%20each%20evaluation%20direction.%0A//%09%09%09%09%09%20%20%20%20%20If%20it%20hits%20something%2C%20hitDistance%20containts%20the%20distance%20to%20the%20hit.%0A//%09%09%09%09%09%20%20%20%20%20If%20it%20doesn%27t%20hit%20anything%2C%20it%27s%20set%20to%20undefined.%0A//%0A//%20Expected%20Return%3A%0A//%20%09A%20single%20number%20%28scalar%20float%29%20that%20is%20the%20evalution%20of%20the%20function%20for%20the%20specified%20input.%0A%0Areturn%20Math.abs%28x%29%3C1%20%3F%201%20%3A%200%3B");
						functionGraph.convolutionFunctionStr = unescape("//%20Type%20your%20convolution%20function%20here%2C%20using%20valid%20JavaScript.%0A//%0A//%20Parameters%3A%0A//%20%09dx%3A%20%5BCartesian%5D%20The%20distance%20along%20the%20X%20axis%20from%20the%20center%20value%20that%20the%20convolution%20function%20needs%20to%20be%20evaluated%20at.//%20%09dx%3A%20%5BPolar%5D%20The%20angle%2C%20in%20radians%2C%20from%20the%20center%20value%20that%20the%20convolution%20function%20needs%20to%20be%20evaluated%20at.%0A//%0A//%20Expected%20Return%3A%0A//%20%09A%20single%20number%20%28scalar%20float%29%20that%20is%20the%20evalution%20of%20the%20convolution%20function%20for%20the%20specified%20input.%0A%0Areturn%201-saturate%28Math.abs%28dx%29/1%29%3B");
						functionGraph.coordinateType =  0;
						functionGraph.xAxis = new Vector(1, 0);
						functionGraph.xMin = -1.7000000000000002;
						functionGraph.xMax = 1.7000000000000002;
						functionGraph.evalStep = 0;
						functionGraph.xLabel = 0;
						functionGraph.showXAxis = true;
						functionGraph.xLabelStep = 1;
						functionGraph.xLabelDecimals = 0;
						functionGraph.xGridlines = false;
						functionGraph.yLabel = 0;
						functionGraph.showYAxis = true;
						functionGraph.yLabelStep = 1;
						functionGraph.yLabelDecimals = 0;
						functionGraph.yGridlines = false;
						functionGraph.evaluateOnMouseCursor = false;
						functionGraph.doConvolution = false;
						functionGraph.doRayCasting = true;
						functionGraph.yLimitMin = -0.1;
						functionGraph.yLimitMax = 1.5;
						functionGraph.graphOriginLocal = new Vector(0, 0);
						functionGraph.visible = true;
						functionGraph.frozen = false;
						functionGraph.yFunction = undefined;
						functionGraph.convolutionFunction = undefined;
						functionGraph.onChange();
						scene.addObject(functionGraph);
					}

					if (showTent)
					{
						var functionGraph = new FunctionGraph(new Vector(0, 0));
						functionGraph.appearance.lineWidth = 2;
						functionGraph.appearance.lineRGB[0] = 66;
						functionGraph.appearance.lineRGB[1] = 134;
						functionGraph.appearance.lineRGB[2] = 244;
						functionGraph.appearance.lineAlpha = 1;
						functionGraph.appearance.lineDashIndex = 0;
						functionGraph.appearance.fillRGB[0] = 0;
						functionGraph.appearance.fillRGB[1] = 127;
						functionGraph.appearance.fillRGB[2] = 255;
						functionGraph.appearance.fillAlpha = 0.5;
						functionGraph.functionStr = unescape("//%20Type%20your%20function%20here%2C%20using%20valid%20JavaScript.%0A//%0A//%20Parameters%3A%0A//%20%09x%3A%20%5BCartesian%5D%20The%20value%20on%20the%20X%20axis%20on%20which%20the%20function%20needs%20to%20be%20evaluated%20at.%0A//%20%09x%3A%20%5BPolar%5D%20The%20angle%2C%20in%20radians%2C%20which%20the%20function%20needs%20to%20be%20evaluated%20at.%0A//%0A//%20%09hitDistance%3A%20%5BCartesian%5D%20A%20ray%20is%20shot%20along%20the%20Y%20axis%2C%20starting%20at%20each%20evaluation%20position.%0A//%20%09hitDistance%3A%20%5BPolar%5D%20A%20ray%20is%20shot%20for%20each%20evaluation%20direction.%0A//%09%09%09%09%09%20%20%20%20%20If%20it%20hits%20something%2C%20hitDistance%20containts%20the%20distance%20to%20the%20hit.%0A//%09%09%09%09%09%20%20%20%20%20If%20it%20doesn%27t%20hit%20anything%2C%20it%27s%20set%20to%20undefined.%0A//%0A//%20Expected%20Return%3A%0A//%20%09A%20single%20number%20%28scalar%20float%29%20that%20is%20the%20evalution%20of%20the%20function%20for%20the%20specified%20input.%0A%0Areturn%20Math.max%281-Math.abs%28x/1%29%2C%200%29%3B");
						functionGraph.convolutionFunctionStr = unescape("//%20Type%20your%20convolution%20function%20here%2C%20using%20valid%20JavaScript.%0A//%0A//%20Parameters%3A%0A//%20%09dx%3A%20%5BCartesian%5D%20The%20distance%20along%20the%20X%20axis%20from%20the%20center%20value%20that%20the%20convolution%20function%20needs%20to%20be%20evaluated%20at.//%20%09dx%3A%20%5BPolar%5D%20The%20angle%2C%20in%20radians%2C%20from%20the%20center%20value%20that%20the%20convolution%20function%20needs%20to%20be%20evaluated%20at.%0A//%0A//%20Expected%20Return%3A%0A//%20%09A%20single%20number%20%28scalar%20float%29%20that%20is%20the%20evalution%20of%20the%20convolution%20function%20for%20the%20specified%20input.%0A%0Areturn%201-saturate%28Math.abs%28dx%29/1%29%3B");
						functionGraph.coordinateType = 0;
						functionGraph.xAxis = new Vector(1, 0);
						functionGraph.xMin = -1.7000000000000002;
						functionGraph.xMax = 1.7000000000000002;
						functionGraph.evalStep = 0.1;
						functionGraph.xLabel = 0;
						functionGraph.showXAxis = true;
						functionGraph.xLabelStep = 1;
						functionGraph.xLabelDecimals = 0;
						functionGraph.xGridlines = false;
						functionGraph.yLabel = 0;
						functionGraph.showYAxis = true;
						functionGraph.yLabelStep = 1;
						functionGraph.yLabelDecimals = 0;
						functionGraph.yGridlines = false;
						functionGraph.evaluateOnMouseCursor = false;
						functionGraph.doConvolution = false;
						functionGraph.doRayCasting = true;
						functionGraph.yLimitMin = 0;
						functionGraph.yLimitMax = 1.5;
						functionGraph.graphOriginLocal = new Vector(0, 0);
						functionGraph.visible = true;
						functionGraph.frozen = false;
						functionGraph.yFunction = undefined;
						functionGraph.convolutionFunction = undefined;
						functionGraph.onChange();
						scene.addObject(functionGraph);
					}

					if (showGaussian)
					{
						var functionGraph = new FunctionGraph(new Vector(0, 0));
						functionGraph.appearance.lineWidth = 2;
						functionGraph.appearance.lineRGB[0] = 66;
						functionGraph.appearance.lineRGB[1] = 134;
						functionGraph.appearance.lineRGB[2] = 244;
						functionGraph.appearance.lineAlpha = 1;
						functionGraph.appearance.lineDashIndex = 0;
						functionGraph.appearance.fillRGB[0] = 0;
						functionGraph.appearance.fillRGB[1] = 255;
						functionGraph.appearance.fillRGB[2] = 0;
						functionGraph.appearance.fillAlpha = 0.5;
						functionGraph.functionStr = unescape("//%20Type%20your%20function%20here%2C%20using%20valid%20JavaScript.%0A//%0A//%20Parameters%3A%0A//%20%09x%3A%20%5BCartesian%5D%20The%20value%20on%20the%20X%20axis%20on%20which%20the%20function%20needs%20to%20be%20evaluated%20at.%0A//%20%09x%3A%20%5BPolar%5D%20The%20angle%2C%20in%20radians%2C%20which%20the%20function%20needs%20to%20be%20evaluated%20at.%0A//%0A//%20%09hitDistance%3A%20%5BCartesian%5D%20A%20ray%20is%20shot%20along%20the%20Y%20axis%2C%20starting%20at%20each%20evaluation%20position.%0A//%20%09hitDistance%3A%20%5BPolar%5D%20A%20ray%20is%20shot%20for%20each%20evaluation%20direction.%0A//%09%09%09%09%09%20%20%20%20%20If%20it%20hits%20something%2C%20hitDistance%20containts%20the%20distance%20to%20the%20hit.%0A//%09%09%09%09%09%20%20%20%20%20If%20it%20doesn%27t%20hit%20anything%2C%20it%27s%20set%20to%20undefined.%0A//%0A//%20Expected%20Return%3A%0A//%20%09A%20single%20number%20%28scalar%20float%29%20that%20is%20the%20evalution%20of%20the%20function%20for%20the%20specified%20input.%0A%0Avar%20sigma%20%3D%200.3%3B%0Avar%20sigmaSq%20%3D%20sigma*sigma%3B%0Areturn%20Math.exp%28-x*x/%282*sigmaSq%29%29");
						functionGraph.convolutionFunctionStr = unescape("//%20Type%20your%20convolution%20function%20here%2C%20using%20valid%20JavaScript.%0A//%0A//%20Parameters%3A%0A//%20%09dx%3A%20%5BCartesian%5D%20The%20distance%20along%20the%20X%20axis%20from%20the%20center%20value%20that%20the%20convolution%20function%20needs%20to%20be%20evaluated%20at.//%20%09dx%3A%20%5BPolar%5D%20The%20angle%2C%20in%20radians%2C%20from%20the%20center%20value%20that%20the%20convolution%20function%20needs%20to%20be%20evaluated%20at.%0A//%0A//%20Expected%20Return%3A%0A//%20%09A%20single%20number%20%28scalar%20float%29%20that%20is%20the%20evalution%20of%20the%20convolution%20function%20for%20the%20specified%20input.%0A%0Areturn%201-saturate%28Math.abs%28dx%29/1%29%3B");
						functionGraph.coordinateType = 0;
						functionGraph.xAxis = new Vector(1, 0);
						functionGraph.xMin = -1.7000000000000002;
						functionGraph.xMax = 1.7000000000000002;
						functionGraph.evalStep = 0;
						functionGraph.xLabel = 0;
						functionGraph.showXAxis = true;
						functionGraph.xLabelStep = 1;
						functionGraph.xLabelDecimals = 0;
						functionGraph.xGridlines = false;
						functionGraph.yLabel = 0;
						functionGraph.showYAxis = true;
						functionGraph.yLabelStep = 1;
						functionGraph.yLabelDecimals = 0;
						functionGraph.yGridlines = false;
						functionGraph.evaluateOnMouseCursor = false;
						functionGraph.doConvolution = false;
						functionGraph.doRayCasting = true;
						functionGraph.yLimitMin = -0.2;
						functionGraph.yLimitMax = 1.5;
						functionGraph.graphOriginLocal = new Vector(0, 0);
						functionGraph.visible = true;
						functionGraph.frozen = false;
						functionGraph.yFunction = undefined;
						functionGraph.convolutionFunction = undefined;
						functionGraph.onChange();
						scene.addObject(functionGraph);
					}
				}

				addControls();
				makeScene();
				embeddedObj.zoomExtents();
			}

			function ShowConvolutionExample(divName, controlsDivName, defaultFunction, polar)
			{
				var embeddedObj=new EmbeddedDrawing(divName);
				var scene=embeddedObj.getScene();
				var camera=embeddedObj.camera;

				var textObject = undefined;
				var baseFunction = undefined;
				var filterFunction = undefined;
				var convolvedFunction = undefined;

				var inputFunctionIndex = defaultFunction;
				var filterIndex = 0;
				var filterWidth = 1;
				var randomSeed = 4;

				var interactiveReveal = true;
				var xValuesRevealed;

				function addControls()
				{
					if (controlsDivName == undefined)
						return;

					var inputFunctionControl = new Dropdown(["Square Wave", "Random"], inputFunctionIndex, function(value) { inputFunctionIndex = value; makeScene(); });

					var randomSeedControl = new Slider(1, 9, randomSeed, 1, function(value) { randomSeed = value; makeScene(); });

					var filterControl = new Dropdown(["Box", "Tent", "Gaussian"], filterIndex, function(value) { filterIndex = value; makeScene(); });

					var filterWidthControl = new Slider(1, 5, filterWidth, 1, function(value) { filterWidth = value; makeScene(); });

					var interactiveControl = new TickBox(interactiveReveal, function (value) { interactiveReveal = value; makeScene(); });

					var controls = new PropertyGrid(document.getElementById(controlsDivName));

					controls.addProperty("Base Function", inputFunctionControl);
					controls.addProperty("Variant", randomSeedControl);
					controls.addProperty("Filter Function", filterControl);
					controls.addProperty("Filter Width", filterWidthControl);
					if (!polar) controls.addProperty("Interactive graph calculation", interactiveControl);
				}

				function makeScene()
				{
					scene.deleteAllObjects();

					var baseFunctionStr;
					var baseFunctionRevealedStr;
					var filterFunctionStr;
					var convolvedFunctionStr;

					if (inputFunctionIndex == 1)
					{
						if (polar)
						{
							baseFunctionStr = "var result = 0; for (var power=-2; power!=8; ++power) { var cycle = Math.pow(2, power); result += Math.cos(x*8/cycle) * pseudoRandom.random(this.randomSeed + x + power) * Math.pow(1.1, power); } return result;";

							baseFunctionRevealedStr = baseFunctionStr;
						}
						else
						{
							baseFunctionStr = "var result = 0; for (var power=-2; power!=8; ++power) { var cycle = Math.pow(2, power); result += Math.cos(x * Math.PI/cycle) * pseudoRandom.random(this.randomSeed + x + power) * Math.pow(1.1, power); } return result;";

							baseFunctionRevealedStr = "var result = 0; for (var power=-2; power!=8; ++power) { var cycle = Math.pow(2, power); result += Math.cos(x * Math.PI/cycle) * pseudoRandom.random(this.randomSeed + x + power) * Math.pow(1.1, power); } var index = Math.round((baseX - this.xMin) / this.evalStep); result *= this.xValuesRevealed[index]; return result;";
						}
					}
					else
					{
						if (polar)
						{
							baseFunctionStr = "return (Math.cos(x*(2+this.randomSeed))>0)*5;"
							baseFunctionRevealedStr = baseFunctionStr;
						}
						else
						{
							baseFunctionStr = "return (Math.cos(x/4*Math.PI)>0)*5;"
							baseFunctionRevealedStr = "var index = Math.round((baseX - this.xMin) / this.evalStep); return (Math.cos(x/4*Math.PI)>0)*5*this.xValuesRevealed[index];"
						}
					}

					if (filterIndex == 1)
					{
						filterFunctionStr = "return 1-saturate(abs(x)/" + filterWidth + ");"
						convolvedFunctionStr = "return 1-saturate(abs(dx)/" + filterWidth + ");"
					}
					else if (filterIndex == 2)
					{
						filterFunctionStr = "var sigma = 0.3 * " + filterWidth + "; var sigmaSq = sigma*sigma; return Math.exp(-x*x/(2*sigmaSq));"
						convolvedFunctionStr = "var sigma = 0.3 * " + filterWidth + "; var sigmaSq = sigma*sigma; return Math.exp(-dx*dx/(2*sigmaSq));"
					}
					else
					{
						filterFunctionStr = "return Math.abs(x)<" + filterWidth + " ? 1 : 0;"
						convolvedFunctionStr = "return Math.abs(dx)<" + filterWidth + " ? 1 : 0;"
					}

					var text = new Text(new Vector(0, 12), unescape("Move%20mouse%20here%21"));
					text.halign = "1";
					text.valign = "1";
					text.font = "Arial";
					text.fontSize = 2;
					text.appearance.lineWidth = 3;
					text.appearance.lineRGB[0] = 255;
					text.appearance.lineRGB[1] = 64;
					text.appearance.lineRGB[2] = 0;
					text.appearance.lineAlpha = 1;
					text.appearance.lineDashIndex = 0;
					text.appearance.fillRGB[0] = 127;
					text.appearance.fillRGB[1] = 127;
					text.appearance.fillRGB[2] = 127;
					text.appearance.fillAlpha = 0;
					text.angle = 0;
					text.lineSpacing = 1.6;
					text.visible = polar || !interactiveReveal ? 0 : 1;
					text.frozen = false;
					text.maxWidth = 8.279567824469673;
					text.totalHeight = 1.3324648539225261;
					scene.addObject(text);
					textObject = text;

					var functionGraph = new FunctionGraph(new Vector(0, 15));
					functionGraph.appearance.lineWidth = 2;
					functionGraph.appearance.lineRGB[0] = 66;
					functionGraph.appearance.lineRGB[1] = 134;
					functionGraph.appearance.lineRGB[2] = 244;
					functionGraph.appearance.lineAlpha = 1;
					functionGraph.appearance.lineDashIndex = 0;
					functionGraph.appearance.fillRGB[0] = 255;
					functionGraph.appearance.fillRGB[1] = 127;
					functionGraph.appearance.fillRGB[2] = 0;
					functionGraph.appearance.fillAlpha = 0.5;
					functionGraph.functionStr = baseFunctionStr;
					functionGraph.convolutionFunctionStr = unescape("//%20Type%20your%20convolution%20function%20here%2C%20using%20valid%20JavaScript.%0A//%0A//%20Parameters%3A%0A//%20%09dx%3A%20%5BCartesian%5D%20The%20distance%20along%20the%20X%20axis%20from%20the%20center%20value%20that%20the%20convolution%20function%20needs%20to%20be%20evaluated%20at.//%20%09dx%3A%20%5BPolar%5D%20The%20angle%2C%20in%20radians%2C%20from%20the%20center%20value%20that%20the%20convolution%20function%20needs%20to%20be%20evaluated%20at.%0A//%0A//%20Expected%20Return%3A%0A//%20%09A%20single%20number%20%28scalar%20float%29%20that%20is%20the%20evalution%20of%20the%20convolution%20function%20for%20the%20specified%20input.%0A%0Areturn%201-saturate%28Math.abs%28dx%29/1%29%3B");
					functionGraph.coordinateType = polar ? 1 : 0;
					functionGraph.xAxis = new Vector(1, 0);
					functionGraph.xMin = polar? 0:-11;
					functionGraph.xMax = polar? Math.PI*2:11;
					functionGraph.evalStep = polar ? 1 * Math.PI/180 : camera.invScale(2);//0.1;
					functionGraph.xLabel = 2;
					functionGraph.showXAxis = true;
					functionGraph.xLabelStep = polar ? 45 * Math.PI / 180 : 1;
					functionGraph.xLabelDecimals = 0;
					functionGraph.xGridlines = false;
					functionGraph.yLabel = 2;
					functionGraph.showYAxis = true;
					functionGraph.yLabelStep = 1;
					functionGraph.yLabelDecimals = 0;
					functionGraph.yGridlines = false;
					functionGraph.evaluateOnMouseCursor = false;
					functionGraph.doConvolution = false;
					functionGraph.doRayCasting = true;
					functionGraph.yLimitMin = 0;
					functionGraph.yLimitMax = 11;
					functionGraph.graphOriginLocal = new Vector(0, 0);
					functionGraph.visible = true;
					functionGraph.frozen = false;
					functionGraph.randomSeed = randomSeed;
					//functionGraph.useCache = false;
					functionGraph.yFunction = undefined;
					functionGraph.convolutionFunction = undefined;
					functionGraph.onChange();
					scene.addObject(functionGraph);
					baseFunction = functionGraph;

					var functionGraph = new FunctionGraph(new Vector(0, 11));
					functionGraph.appearance.lineWidth = 2;
					functionGraph.appearance.lineRGB[0] = 66;
					functionGraph.appearance.lineRGB[1] = 134;
					functionGraph.appearance.lineRGB[2] = 244;
					functionGraph.appearance.lineAlpha = 1;
					functionGraph.appearance.lineDashIndex = 0;
					functionGraph.appearance.fillRGB[0] = 255;
					functionGraph.appearance.fillRGB[1] = 127;
					functionGraph.appearance.fillRGB[2] = 0;
					functionGraph.appearance.fillAlpha = 0.5;
					functionGraph.functionStr = filterFunctionStr;
					functionGraph.convolutionFunctionStr = unescape("//%20Type%20your%20convolution%20function%20here%2C%20using%20valid%20JavaScript.%0A//%0A//%20Parameters%3A%0A//%20%09dx%3A%20%5BCartesian%5D%20The%20distance%20along%20the%20X%20axis%20from%20the%20center%20value%20that%20the%20convolution%20function%20needs%20to%20be%20evaluated%20at.//%20%09dx%3A%20%5BPolar%5D%20The%20angle%2C%20in%20radians%2C%20from%20the%20center%20value%20that%20the%20convolution%20function%20needs%20to%20be%20evaluated%20at.%0A//%0A//%20Expected%20Return%3A%0A//%20%09A%20single%20number%20%28scalar%20float%29%20that%20is%20the%20evalution%20of%20the%20convolution%20function%20for%20the%20specified%20input.%0A%0Areturn%201-saturate%28Math.abs%28dx%29/1%29%3B");
					functionGraph.coordinateType = polar ? 1 : 0;
					functionGraph.xAxis = new Vector(1, 0);
					functionGraph.xMin = polar? 0:-filterWidth;
					functionGraph.xMax = polar? Math.PI*2:filterWidth;
					functionGraph.evalStep = 0.01;
					functionGraph.xLabel = 2;
					functionGraph.showXAxis = 0;
					functionGraph.xLabelStep = polar ? 45 * Math.PI / 180 : 1;
					functionGraph.xLabelDecimals = 0;
					functionGraph.xGridlines = false;
					functionGraph.yLabel = 2;
					functionGraph.showYAxis = 0;
					functionGraph.yLabelStep = 1;
					functionGraph.yLabelDecimals = 0;
					functionGraph.yGridlines = false;
					functionGraph.evaluateOnMouseCursor = false;
					functionGraph.doConvolution = false;
					functionGraph.doRayCasting = true;
					functionGraph.yLimitMin = 0;
					functionGraph.yLimitMax = 1.9;
					functionGraph.graphOriginLocal = new Vector(0, 0);
					functionGraph.visible = polar ? 0 : 0;
					functionGraph.frozen = false;
					//functionGraph.useCache = false;
					functionGraph.yFunction = undefined;
					functionGraph.convolutionFunction = undefined;
					functionGraph.onChange();
					scene.addObject(functionGraph);

					filterFunction = functionGraph;

					var functionGraph = new FunctionGraph(new Vector(0, 2));
					functionGraph.appearance.lineWidth = 2;
					functionGraph.appearance.lineRGB[0] = 66;
					functionGraph.appearance.lineRGB[1] = 134;
					functionGraph.appearance.lineRGB[2] = 244;
					functionGraph.appearance.lineAlpha = 1;
					functionGraph.appearance.lineDashIndex = 0;
					functionGraph.appearance.fillRGB[0] = 255;
					functionGraph.appearance.fillRGB[1] = 127;
					functionGraph.appearance.fillRGB[2] = 0;
					functionGraph.appearance.fillAlpha = 0.5;
					functionGraph.functionStr = baseFunctionRevealedStr;
					functionGraph.convolutionFunctionStr = convolvedFunctionStr;
					functionGraph.coordinateType = polar ? 1 : 0;
					functionGraph.xAxis = new Vector(1, 0);
					functionGraph.xMin = polar? 0:-11;
					functionGraph.xMax = polar? Math.PI*2:11;
					functionGraph.evalStep = polar ? 2 * Math.PI/180 : 0.1;
					functionGraph.xLabel = 2;
					functionGraph.showXAxis = true;
					functionGraph.xLabelStep = polar ? 45 * Math.PI / 180 : 1;
					functionGraph.xLabelDecimals = 0;
					functionGraph.xGridlines = false;
					functionGraph.yLabel = 2;
					functionGraph.showYAxis = true;
					functionGraph.yLabelStep = 1;
					functionGraph.yLabelDecimals = 0;
					functionGraph.yGridlines = false;
					functionGraph.evaluateOnMouseCursor = false;
					functionGraph.doConvolution = true;
					functionGraph.doRayCasting = true;
					functionGraph.yLimitMin = 0;
					functionGraph.yLimitMax = 7;
					functionGraph.graphOriginLocal = new Vector(0, 0);
					functionGraph.visible = true;
					functionGraph.frozen = false;
					functionGraph.randomSeed = randomSeed;
					functionGraph.useCache = false;

					var count = Math.ceil( (functionGraph.xMax - functionGraph.xMin) / functionGraph.evalStep ) + 2;
					xValuesRevealed = new Array(count);

					for (var i=0; i!=xValuesRevealed.length; ++i)
						xValuesRevealed[i] = interactiveReveal ? 0 : 1;

					functionGraph.xValuesRevealed = xValuesRevealed;

					functionGraph.yFunction = undefined;
					functionGraph.convolutionFunction = undefined;
					functionGraph.onChange();
					scene.addObject(functionGraph);

					convolvedFunction = functionGraph;
				}

				embeddedObj.onMouseMove = function (m, mp, buttons, ctrlKey, shiftKey)
				{
					if (!polar)
					{
						embeddedObj.setRedrawOnChange(false);

						if (textObject!=undefined)
						{
							textObject.toggleVisibility(0);
						}

						if (filterFunction != undefined)
						{
							filterFunction.toggleVisibility(1);
						}

						var filterGraphX = m.x;

						if (filterFunction != undefined)
						{
							filterGraphX = filterFunction.getOrigin().x;
						}

						// Update visible part of convolution graph
						if (interactiveReveal)
						{
							var delta = camera.invScale(4);
							for (var dx=-delta; dx<=delta; dx += convolvedFunction.evalStep)
							{
								var index = Math.round((filterGraphX + dx - convolvedFunction.xMin) / convolvedFunction.evalStep); 
								xValuesRevealed[index] = 1;
							}
						}	

						// Debug lines
						{
							// From filter graph to base graph
							{
								var count = Math.round((convolvedFunction.convolutionFunctionMaxX - convolvedFunction.convolutionFunctionMinX) / camera.invScale(5));

								var points = [];
								var pointsDashed = [];

								for (var i=0; i!=count; ++i)
								{
									var dx = lerp(convolvedFunction.convolutionFunctionMinX, convolvedFunction.convolutionFunctionMaxX, i/(count-1));

									dx = Math.round(dx / filterFunction.evalStep) * filterFunction.evalStep;

									var x = filterGraphX + dx;

									x = Math.round(x / baseFunction.evalStep) * baseFunction.evalStep;

									var p0 = new Vector();
									p0.x = x;
									p0.y = filterFunction.getOrigin().y + filterFunction.yFunction(dx) + camera.invScale(5);

									p1 = new Vector()
									p1.x = x;
									p1.y = baseFunction.getOrigin().y + baseFunction.yFunction(x);

									if (baseFunction.yFunction(x)>0)
									{
										points.push(p0);
										points.push(p1);
									}
									else
									{
										pointsDashed.push(p0);
										pointsDashed.push(p1);
									}
								}

								camera.drawLines(points, "#FF0000", 2);
								camera.drawLines(pointsDashed, "rgba(255,0,0,0.3)", 2);
							}

							// From filter to convolution graph
							{
								var p = new Vector();
								p.x = filterGraphX;
								p.y = 0.5 * (filterFunction.getOrigin().y + baseFunction.getOrigin().y);
								camera.drawText(p, "×", "#000000", "center");

								var p0 = new Vector();
								p0.x = Math.round(filterGraphX / convolvedFunction.evalStep) * convolvedFunction.evalStep;
								p0.y = filterFunction.getOrigin().y - camera.invScale(2);

								var p1 = new Vector();
								p1.x = p0.x;
								p1.y = convolvedFunction.getOrigin().y + convolvedFunction.graphFunction(p1.x);

								var radius = 0.5 * (convolvedFunction.convolutionFunctionMaxX - convolvedFunction.convolutionFunctionMinX);

								camera.drawLine(	add(p0, new Vector(-radius, 0)), 
													add(p0, new Vector(-radius + camera.invScale(10), -camera.invScale(15))), "#FF0000", 2);

								camera.drawLine(	add(p0, new Vector(+radius, 0)), 
													add(p0, new Vector(+radius - camera.invScale(10), -camera.invScale(15))), "#FF0000", 2);

								camera.drawLine(	add(p0, new Vector(-radius + camera.invScale(10), -camera.invScale(15))),
													add(p0, new Vector(+radius - camera.invScale(10), -camera.invScale(15))), "#FF0000", 2);

								camera.drawText(add(p0, new Vector(0, -camera.invScale(12))), "Σ", "#000000", "center");

								camera.drawArrow(add(p0, new Vector(0, -camera.invScale(15))), p1, 8, "#FF0000", 2);
								camera.drawArc(p1, camera.invScale(5), 0, Math.PI*2, "#008000", 2);
							}
						}

						// Update filter graph position
						{
							var p = filterFunction.getOrigin().copy();
							p.x = m.x;

							p.x = Math.round(p.x / baseFunction.evalStep) * baseFunction.evalStep;

							filterFunction.setOrigin(p);
						}

						embeddedObj.setRedrawOnChange(true);
					}

					return true;
				}

				embeddedObj.onMouseLeave = function()
				{
					if (filterFunction != undefined)
					{
						filterFunction.toggleVisibility(0);
					}

					embeddedObj.draw();
				}

				embeddedObj.onFrameTick = function(deltaTime_ms, accumulatedTime_ms)
				{
					if (textObject.isVisible())
					{
						textObject.fontSize = lerp(2, 2.2, (Math.sin(accumulatedTime_ms / 1000 * Math.PI * 2) * 0.5 + 0.5));
						textObject.onChange();
					}
				}

				addControls();
				makeScene();
				embeddedObj.zoomExtents();
			}

</script></pre>

	I recently added support for convolution integrals on the Function Graph object in the <a href="https://renderdiagrams.org/editor.html" target="_blank" rel="noopener">editor</a>. I thought I'd take the opportunity to write a quick introduction on the topic and present a few interactive diagrams. As with previous posts, this is not meant to be a complete teaching resource on convolution integrals. There are many excellent resources out there already! It's just another take on them with some, hopefully interesting, diagrams.
	<!--more-->

	Note, if you already know all about convolution integrals and just want to see some nice interactive diagrams, just scroll down to <a href="#diagrams">here</a>!

	Wikipedia has a good page on <a href="https://en.wikipedia.org/wiki/Convolution" target="_blank" rel="noopener" title="Wikipedia link">convolution integrals</a> which covers some of their mathematical background. I personally found that I understand them much better in the context of 2D images. Let's work backwards a little and assume you want to blur a 2D image. As a graphics programmer you might write a pixel shader that samples a few texels around the position you're writing to, average them, and output the resulting color. You'd then run this shader over ever pixel of your target image. Intuitively, you'd understand that the wider your sampling pattern, the blurrier the resulting image would be.

	Let's try and turn this into pseudo-code.

	[code]
	For each output pixel:
		Sample a bunch of texels from image.
		Average them.
		Write to output.[/code]

	Those 'bunch of texels' aren't just anywhere in the source image though. They are in the vicinity of the pixel we're rendering. Let's amend the pseudo-code.

	[code highlight=2]
	For each output pixel p:
		Sample all the texels that are in the vicinity of p.
		Average them.
		Write to output.[/code]

	What if we were to clarify what 'in the vicinity of p' meant? Let's express it as those texels that are within a certain distance threshold from p.

	[code highlight=2]
	For each output pixel p:
		Sample all the texels whose distance from p is less than threshold.
		Average them.
		Write to output.[/code]

	Ok, how do we find all the texels that are within a certain distance of p? Let's pretend that performance isn't an issue and that reading every texel on the source image is free. We might then write code like this:

	[code highlight=5,6]
	For each output pixel p:
	
		average = 0;

		For each input texel t:
			if (distance(t,p)<=threshold)
				average += image(t);

		Average them.

		Write to output.[/code]

	Based on the logic above we make a binary decision to either include or exclude a texel in our calculation. If it's within our distance threshold we include it, other we don't. What if we were to express that as a multiplier? We'll multiply by 1 if we want to include the texel, and by 0 if we want to exclude it.

	[code highlight=7,9]
	For each output pixel p:
	
		average = 0;

		For each input texel t:
			if (distance(t,p)<=threshold)
				average += image(t) * 1;
			else
				average += image(t) * 0;

		Average them.

		Write to output.[/code]

	Let's start calling this mutliplier a 'weight'. Our algorithm works out the weight of each texel, i.e. how much it contributes towards that average.

	[code highlight=8,10,12]
	For each output pixel p:
	
		average = 0;

		For each input texel t:
			weight = 0;
			if (distance(t,p)<=threshold)
				weight = 1;
			else
				weight = 0;

			average += image(t) * weight;

		Average them.

		Write to output.[/code]

	Now, let's take a look at that 'Average them' statement. The blur operation takes in contributions from many texels and produces a single color. As long as the contibution from each (participating) texel is the same, then combining them together simply means taking their average. Since participating texels have a weight of 1 and non-participating a weight of zero, then simply adding up the weights will give us the number of participating texels.

	[code highlight=14,16]
	For each output pixel p:
	
		average = 0;
		totalWeight = 0;

		For each input texel t:
			weight = 0;
			if (distance(t,p)<=threshold)
				weight = 1;
			else
				weight = 0;

			average += image(t) * weight;
			totalWeight += weight;

		average /= totalWeight;

		Write to output.[/code]

	Expressing things via weight and totalWeight allows for an important mental leap. Not all contributions have to be the same. Each texel may contribute a different amount towards the final pixel. As long as we add up all the weights and divide the sum of the weighted texels by the sum of the contributions then we'll a (mathematically) correct answer. This is known as <a href="https://en.wikipedia.org/wiki/Weighted_arithmetic_mean" target="_blank" rel="noopener" title="Wikipedia link">weighted average</a>.

	Let's rearrange the above pseudo-code a little to decouple the averaging process to the weight calculation.

	[code highlight=1-5,13]
	function TexelWeight(delta)
		if (delta<=threshold)
			return 1;
		else
			return 0;

	For each output pixel p:
	
		average = 0;
		totalWeight = 0;

		For each input texel t:
			weight = TexelWeight(distance(t,p));
			average += image(t) * weight;
			totalWeight += weight;

		average /= totalWeight;

		Write to output.[/code]

	The averaging process hold true regardless of the implementation of the <code>TexelWeight</code> function. We just need that function to return the contribution weight, given the distance of the texel being considered away from the pixel being rendered.

	The input to the weight function is important. Rather than passing t and p, we're passing the (signed) distance between them. We'll visualize this in a bit, but this effectively means that the weight function moves/slides across the domain of the input function. Passing a distance of zero means we're asking for the contribution of the texel at the same location as the pixel we're writing to. Passing distances away from zero means we're asking for the contibution factors of the texels away from the pixel being shaded.

	If we think of <code>TexelWeight</code> as more of mathematical rather than programming function, we should be able to plot its graph.

	We can do this in the editor. Just add a Function Graph object and set the function code to this:
	(or just right click on the diagram area and select Edit Local Copy!)

	[code language="javascript"]
	return Math.abs(x)<1 ? 1 : 0;[/code]

	<div id="embeddedDrawing_filter_function_box" style="width: 70%; padding-bottom: 70%; margin:0 auto 1em;"></div>

	<pre style="display:none;"><script>
	ShowFilterFunctions("embeddedDrawing_filter_function_box", undefined, true, false, false, false);
	</script></pre>

	This type of filtering function is called a box filter and it's characterised by the fact that all contributing samples have the same weight, i.e. it's a straight average. Note that in the above formulation we normalize the sum by dividing by the sum of the weights. You'll often see filtering functions (or 'kernels') where the weights have already been normalised so that they add up to 1.

	The Box, Tent, and Gaussian filters are three of the most commonly used filters.

	<div id="controls_filter_functions" style="width: 70%; margin:0 auto;"></div>
	<div id="embeddedDrawing_filter_functions" style="width: 70%; padding-bottom: 70%; margin:0 auto 1em;"></div>

	<pre style="display:none;"><script>
		ShowFilterFunctions("embeddedDrawing_filter_functions", "controls_filter_functions", false, true, false, false);
	</script></pre>

	Notice how all these filtering functions are centered around the x=0 axis. That's because the filtering function is applied over the entire range where the base function is defined, 'grabbing' nearby values and doing a weighted average to produce a set of output values. 
	
	<a id="diagrams"></a>Let's see this in action! On the diagram below we have the base function at the top, the filtering function in the middle and the convolution integral at the bottom row. The convolution process 'fetches' values from the base function, multiplies each value by the value of the filter function and finally adds all these results together. This process happens once for each point on the resulting function. Notice how the filter function 'slides' across the range of the base function, combining multiple input values into a single output.

	<div id="embeddedDrawing_convolution_example" style="width: 70%; padding-bottom: 70%; margin:0 auto 1em;"></div>

	<pre style="display:none;"><script>
		ShowConvolutionExample("embeddedDrawing_convolution_example", undefined, 0);
	</script></pre>

	I'll close things off with some more examples. In the diagram below you can see how a random noise input function is smoothed out by the various filtering kernels. You can try out different filters, but also vary the width of each. The wider the kernel, the smoother the resulting graph becomes.

	<div id="controls_convolution_examples_random" style="width: 70%; margin:0 auto;"></div>
	<div id="embeddedDrawing_convolution_examples_random" style="width: 70%; padding-bottom: 70%; margin:0 auto 1em;"></div>

	<pre style="display:none;"><script>
		ShowConvolutionExample("embeddedDrawing_convolution_examples_random", "controls_convolution_examples_random", 1, false);
	</script></pre>

	All this of course applies to polar graphs as well where things are more interesting and more relevant to graphics programming.

	<div id="controls_convolution_examples_random_polar" style="width: 70%; margin:0 auto;"></div>
	<div id="embeddedDrawing_convolution_examples_random_polar" style="width: 70%; padding-bottom: 70%; margin:0 auto 1em;"></div>

	<pre style="display:none;"><script>
		ShowConvolutionExample("embeddedDrawing_convolution_examples_random_polar", "controls_convolution_examples_random_polar", 1, true);
	</script></pre>

	For a more practical example of how convolution integrals can be used in computer graphics check out the post on <a href="https://renderdiagrams.org/2018/01/05/indirect-illumination-using-cubemaps/" target="_blank" rel="noopener">cubemap filtering</a>!

</body>

</html>
